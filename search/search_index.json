{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"WFX","text":"<p>Note</p> <p>The documentation and APIs are under active development. They may change frequently, so do not expect this documentation to remain fully accurate over time.</p> <p>Explicit, low-level C++ web engine and a framework for people who want control and performance without hiding behavior behind too many abstractions.</p> <p>It provides:</p> <ul> <li>A full HTTP(S) server engine</li> <li>A deterministic request-response lifecycle</li> <li>Global and per-route middleware</li> <li>Streaming (outbound for now)</li> <li>Connection timeouts, rate limiting and security primitives</li> <li>A server-side rendering (SSR) engine with templating</li> <li>Custom asynchronous execution model</li> <li>Built-in form parsing, validation, sanitization and field rendering</li> <li>TOML based configuration</li> </ul> <p>Its design principles are:</p> <ul> <li> <p>Engine-as-source, not a black box   WFX is not a closed runtime. The framework headers and engine code   are part of your build, not an opaque dependency.</p> </li> <li> <p>Minimal magic by default   Behavior is explicit unless you opt into helper macros   (for example, coroutine helpers instead of manual state machines).</p> </li> <li> <p>Deterministic execution   Request handling, middleware order, and ownership semantics   are predictable and controllable.</p> </li> <li> <p>Clear separation of responsibilities   The engine, framework features, and user code are distinct layers,   even though they are compiled together.</p> </li> </ul>"},{"location":"#who-this-is-for","title":"Who this is for","text":"<p>WFX is a good fit if you:</p> <ul> <li>Are comfortable with C++</li> <li>Care about performance and memory behavior without sacrificing built-in features</li> <li>Want full control over engine and framework behavior</li> <li>Prefer transparent behavior over hidden abstractions</li> </ul> <p>WFX is not for you if you:</p> <ul> <li>Expect instant hot reload or scripting-language iteration speeds (compiling engine + user code takes time)</li> <li>Just want to serve simple static pages or single-page apps without managing server-side logic</li> <li>Are uncomfortable with pointers or ownership semantics</li> <li>Hate C++</li> </ul>"},{"location":"#documentation-structure","title":"Documentation structure","text":"<p>If you are new, start here:</p> <p>-&gt; Continue to Installation</p> <p>If you already know what you are doing:</p> <p>-&gt; Continue to API documentation</p>"},{"location":"#developer-note","title":"Developer note","text":"<p>Well if you are considering to use my framework - first of all, Thank You! Right now, i wouldn't recommend you use it for real software, as i will be making a lot of breaking change (and fixing a lot of bugs). You can use it to help contribute to the framework ofc. Other than that, best of luck. You need it :)</p> <p>Continue to Getting Started</p>"},{"location":"api_reference/async/","title":"Async","text":"<p>WFX async is a manual, explicit coroutine system built directly on top of standard C++20 coroutines using <code>Task&lt;&gt;</code> and <code>Promise&lt;&gt;</code> types.</p> <p>Everything is driven by explicit <code>co_await</code> suspension and resumption.</p> <p>Important</p> <p>All async functionality in WFX lives inside the <code>Async::</code> namespace.</p> <p>If you want to directly use built-in async functions such as <code>SleepFor</code>, you must include:</p> <pre><code>#include &lt;async/builtins.hpp&gt;\n</code></pre>"},{"location":"api_reference/async/#overview","title":"Overview","text":"<ul> <li>Async is cooperative</li> <li>No threads are spawned implicitly</li> <li>Execution is deterministic and engine-driven</li> </ul> <p>Async coroutines:</p> <ul> <li>run until they <code>co_await</code></li> <li>suspend explicitly</li> <li>resume only when the engine schedules them</li> <li>finish exactly once</li> </ul>"},{"location":"api_reference/async/#builtins","title":"Builtins","text":"<p>Builtins are predefined awaitables provided by WFX for common async tasks such as sleeping, scheduling, and timing.</p> <p>Builtins behave exactly like user-defined coroutines:</p> <ul> <li>They may suspend</li> <li>They may resume immediately or later</li> <li>They return a status through <code>co_await</code></li> </ul> <p>All builtins are implemented as C++20 awaitable types with:</p> <ul> <li><code>await_ready</code></li> <li><code>await_suspend</code></li> <li><code>await_resume</code></li> </ul> <p>This section documents each builtin and how to use it correctly.</p>"},{"location":"api_reference/async/#asyncsleepfor","title":"<code>Async::SleepFor</code>","text":"<pre><code>SleepForAwaitable SleepFor(std::uint32_t delayMs);\n</code></pre> <p>Description Suspends the current coroutine for <code>delayMs</code> milliseconds</p> <p>Input</p> <ul> <li><code>delayMs</code>: Duration to sleep, in milliseconds</li> </ul> <p>Output</p> <ul> <li>Returns an <code>Async::Status</code> via <code>co_await</code></li> </ul> <p>Error handling</p> <ul> <li> <p>If the timer cannot be scheduled:</p> <ul> <li><code>Async::Status::TIMER_FAILURE</code> is returned</li> <li>The coroutine completes immediately</li> </ul> </li> <li> <p>The caller must check the returned status</p> </li> </ul> <p>Example</p> <pre><code>Async::Status status = co_await Async::SleepFor(500);\n\nif(status != Async::Status::NONE) {\n    // handle timer failure\n}\n</code></pre>"},{"location":"api_reference/constructor/","title":"Constructor","text":"<p>WFX constructors provide a simple way to run one-time user code at engine startup.</p> <p>A constructor is the first user-level callback executed, before any other user macros such as routes, middleware, or similar registrations.</p> <p>Important</p> <p>Constructor requires the user to always include the following header at the top of the file: <pre><code>#include &lt;core/constructor.hpp&gt;\n</code></pre></p>"},{"location":"api_reference/constructor/#what-it-does","title":"What it does","text":"<ul> <li>Runs at the very start of engine initialization</li> <li>Intended for small runtime setup tasks</li> <li>Purely a convenience mechanism</li> </ul> <p>Do not expect it to run again.</p>"},{"location":"api_reference/constructor/#usage","title":"Usage","text":"<pre><code>/*\n * NOTE: The callback signature must be `void(void)`\n */\n\nWFX_CONSTRUCTOR([] {\n    // One-time startup logic\n});\n\n// Or\n\nvoid InitSomething()\n{\n    // One-time startup logic\n}\n\nWFX_CONSTRUCTOR(InitSomething);\n</code></pre> <p>Note</p> <ul> <li>No execution order guarantees</li> <li>Heavy work inside constructor is allowed, but it will directly increase engine startup time</li> <li>Do not throw exceptions; they are not handled If you need to throw, catch and handle them inside the constructor body</li> </ul>"},{"location":"api_reference/forms/","title":"Forms","text":"<p>Forms in WFX provide a statically-defined, explicit, and deterministic way to parse, validate, sanitize, and render structured user input. They are designed to fail fast, avoid ambiguity, and prevent malformed data from ever reaching application logic.</p> <p>Important</p> <p>All form functionality in WFX lives inside the <code>Form::</code> namespace.</p> <p>To use forms, you must include the forms header at the top of your file: <pre><code>#include &lt;core/forms.hpp&gt;\n</code></pre></p>"},{"location":"api_reference/forms/#overview","title":"Overview","text":"<p>A form in WFX consists of four conceptual layers:</p> <ul> <li>Schema: the static, immutable definition of the form</li> <li>Fields: named inputs inside the schema</li> <li>Rules: specifies how each field should be parsed and constrained</li> <li>Cleaning: validation + sanitization (both mandatory, fail as a single step)</li> </ul> <p>Optionally, forms may also define rendering logic for SSR.</p> <p>Each layer is explicit and user-controllable.</p>"},{"location":"api_reference/forms/#form-errors","title":"Form Errors","text":"<p>Every form operation results in a <code>FormError</code>. Forms never throw and never partially succeed.</p> <pre><code>enum class FormError : std::uint8_t {\n    NONE,\n    UNSUPPORTED_CONTENT_TYPE,\n    MALFORMED,\n    CLEAN_FAILED\n};\n</code></pre> <ul> <li><code>NONE</code>: Parsing, validation, and sanitization succeeded</li> <li><code>UNSUPPORTED_CONTENT_TYPE</code>: The request either lacks a <code>Content-Type</code> header or uses a type the form system does not support</li> <li><code>MALFORMED</code>: The request body could not be decoded into key-value input (e.g. broken URL encoding)</li> <li><code>CLEAN_FAILED</code>: One or more fields failed validation or sanitization</li> </ul> <p>If the error is not <code>NONE</code>, application logic must not continue.</p>"},{"location":"api_reference/forms/#form-layers","title":"Form Layers","text":"<p>Each layer has a single responsibility and a clearly defined failure boundary. Understanding these layers is mandatory to use the form system correctly.</p>"},{"location":"api_reference/forms/#schema","title":"Schema","text":"<p>A schema is the complete, immutable definition of a form.</p> <p>In WFX, schemas are represented by <code>Form::FormSchema</code> and are intended to be defined statically.</p> <p>It is constructed with:</p> <ul> <li>The form name (<code>const char*</code>)</li> <li>One or more <code>Form::Field(...)</code> definitions, in order</li> </ul> <p>Example: <pre><code>inline const auto LoginForm = Form::FormSchema{\n    \"login\",\n    Form::Field(\"username\", Form::Text{ .ascii = true, .max = 64 }),\n    Form::Field(\"password\", Form::Text{ .ascii = true, .min = 6, .max = 64 })\n};\n</code></pre></p> <p>This defines a form schema named <code>login</code> with two text fields. This schema is immutable. Fields and rules cannot be changed later.</p> <p>Important</p> <p>Field ordering is critical.</p> <p>Fields are evaluated strictly in the order they are defined inside the schema. This order is used for:</p> <ul> <li>Input parsing and evaluation</li> <li>Validation and sanitization</li> <li>Cleaned tuple layout</li> <li>Field rendering via <code>Render()</code></li> </ul> <p>Changing field order or introducing mismatches can invalidate form input, break tuple access, and produce incorrect or unintended rendering output.</p> <p>Always define fields in the exact order you expect them to be processed and rendered.</p>"},{"location":"api_reference/forms/#fields","title":"Fields","text":"<p>A field represents a single named input expected by the form.</p> <p>Fields are declared using the <code>Form::Field</code> factory function and are always part of a schema. They do not exist independently.</p> <p>A field is constructed with:</p> <ul> <li>The field name (<code>const char*</code>)</li> <li>A rule instance describing the expected input type (e.g. <code>Form::Text</code>, <code>Form::Int</code>)</li> </ul> <p>Example: <pre><code>Form::Field(\"username\", Form::Text{ .ascii = true, .max = 64 })\n</code></pre></p> <p>Custom Overrides</p> <p>All built-in field types provide engine-defined default validators and sanitizers. In most cases, no additional configuration is required.</p> <p>Chaining functions are provided only to override these defaults when needed.</p> <p>Example: <pre><code>// Custom validator and sanitizer\nForm::Field(\"username\", Form::Text{ .ascii = true, .max = 64 })\n        .CustomValidator(&amp;MyValidator)\n        .CustomSanitizer(&amp;MySanitizer)\n\n// Or individually\nForm::Field(\"username\", Form::Text{ .ascii = true, .max = 64 })\n        .CustomValidator(&amp;MyValidator)\n\nForm::Field(\"password\", Form::Text{ .ascii = true, .max = 64 })\n        .CustomSanitizer(&amp;MySanitizer)\n</code></pre></p> <p>Note</p> <ul> <li>Overrides replace the default behavior</li> <li>Overrides do not stack; the last override wins</li> </ul> <p>For details on validators, sanitizers, default behavior, and custom type support, see the Cleaning section.</p>"},{"location":"api_reference/forms/#rules","title":"Rules","text":"<p>A rule defines the expected type and constraints of a field's input.</p> <p>Rules are plain configuration objects. They do not parse input themselves. They are consumed by the form system to perform validation, sanitization, and rendering.</p> <p>Every field must be constructed with exactly one rule instance.</p> <p>Example: <pre><code>Form::Int{ .min = 18, .max = 120 }\n</code></pre></p>"},{"location":"api_reference/forms/#base-interface","title":"Base Interface","text":"<p>All rules MUST inherit the following common property:</p> <pre><code>struct BaseRule {\n    bool required = true;\n};\n</code></pre> <ul> <li><code>required = true</code>: input must be present</li> <li><code>required = false</code>: input may be omitted</li> </ul>"},{"location":"api_reference/forms/#decayed-type","title":"Decayed Type","text":"<p>Each rule is associated with a decayed type, representing the final C++ type produced by the form system after sanitization and validation. This enables compile-time type safety for all form operations</p> <p>The decayed type is determined via the <code>Form::DecayedType&lt;Rule&gt;</code> trait.</p>"},{"location":"api_reference/forms/#builtins","title":"Builtins","text":"<p>WFX provides the following built-in rules:</p> <ul> <li> <p><code>Text</code></p> <p>Usage: <pre><code>Form::Text{\n    .ascii = /* true | false */,\n    .min   = /* minimum length */,\n    .max   = /* maximum length */\n}\n</code></pre></p> <ul> <li><code>ascii</code> (<code>bool</code>): restrict input to ASCII characters only  </li> <li><code>min</code> (<code>std::uint32_t</code>): minimum allowed length  </li> <li><code>max</code> (<code>std::uint32_t</code>): maximum allowed length  </li> </ul> <p>Decayed type: <code>std::string_view</code></p> </li> <li> <p><code>Email</code></p> <p>Usage: <pre><code>Form::Email{\n    .strict = /* true | false */\n}\n</code></pre></p> <ul> <li><code>strict</code> (<code>bool</code>): enable strict email validation rules  </li> </ul> <p>Decayed type: <code>std::string_view</code></p> </li> <li> <p><code>Int</code></p> <p>Usage: <pre><code>Form::Int{\n    .min = /* minimum value */,\n    .max = /* maximum value */\n}\n</code></pre></p> <ul> <li><code>min</code> (<code>std::int64_t</code>): minimum allowed value  </li> <li><code>max</code> (<code>std::int64_t</code>): maximum allowed value  </li> </ul> <p>Decayed type: <code>std::int64_t</code></p> </li> <li> <p><code>UInt</code></p> <p>Usage: <pre><code>Form::UInt{\n    .min = /* minimum value */,\n    .max = /* maximum value */\n}\n</code></pre></p> <ul> <li><code>min</code> (<code>std::uint64_t</code>): minimum allowed value  </li> <li><code>max</code> (<code>std::uint64_t</code>): maximum allowed value  </li> </ul> <p>Decayed type: <code>std::uint64_t</code></p> </li> <li> <p><code>Float</code></p> <p>Usage: <pre><code>Form::Float{\n    .min = /* minimum value */,\n    .max = /* maximum value */\n}\n</code></pre></p> <ul> <li><code>min</code> (<code>double</code>): minimum allowed value  </li> <li><code>max</code> (<code>double</code>): maximum allowed value  </li> </ul> <p>Decayed type: <code>double</code></p> </li> </ul> <p>Note</p> <p>The members shown here are only the members specific to the builtin rule itself. All common members (e.g. <code>.required</code>, etc.) are defined in the <code>BaseRule</code> struct, which is documented earlier in the Base interface section. They are not repeated for each builtin rule to avoid duplication. If a member is not listed here, assume it comes from <code>BaseRule</code> and still applies.</p>"},{"location":"api_reference/forms/#custom","title":"Custom","text":"<p>Custom rules may be defined when built-in rules are insufficient.</p> <p>A custom rule must:</p> <ul> <li>Inherit from <code>Form::BaseRule</code></li> <li>Define its own configuration fields</li> <li>Provide a <code>DecayedType</code> specialization mapping the rule to a concrete value type</li> <li>Have a default sanitizer and validator available to the engine</li> </ul> <p>Example: <pre><code>struct MyRule : Form::BaseRule {\n    std::size_t limit;\n};\n\ntemplate&lt;&gt;\nstruct Form::DecayedType&lt;MyRule&gt; {\n    using Type = std::size_t;\n};\n</code></pre></p> <p>Note</p> <p>More details on default sanitizers, validators, and how to define them are provided in the Cleaning section.</p>"},{"location":"api_reference/forms/#cleaning","title":"Cleaning","text":"<p>The form system processes input in two stages: validation and sanitization, to produce the final C++ value for each field.  </p> <p>Important</p> <p>The order of stages is critical: validation runs before sanitization. The form system first checks that input satisfies the rule constraints, then applies sanitization to produce the final C++ value. All logic should follow this sequence to ensure correct and type-safe processing.</p>"},{"location":"api_reference/forms/#validation","title":"Validation","text":"<p>Validation is the first stage of the cleaning pipeline. It determines whether the raw input is acceptable for a given rule without producing a value.</p> <p>At this stage:</p> <ul> <li>Input is treated as raw <code>std::string_view</code></li> <li>No type conversion is performed</li> <li>The rule is accessed via a type-erased pointer</li> <li>The result is a simple success/failure signal</li> </ul> <p>If validation fails, the pipeline terminates immediately and sanitization is never executed.</p> <p>Validator signature: <pre><code>// Input: Form data, Form field (type erased)\n// Output: Validation success via bool return value\nusing ValidatorFn = bool (*)(std::string_view, const void*);\n</code></pre></p>"},{"location":"api_reference/forms/#sanitization","title":"Sanitization","text":"<p>Sanitization is the second stage of the cleaning pipeline. It is responsible for normalizing and converting already-validated input into a concrete C++ value.</p> <p>At this stage:</p> <ul> <li>Input is still received as <code>std::string_view</code></li> <li>Validation has already succeeded</li> <li>Type conversion and normalization occur here</li> <li>The final decayed C++ value is produced</li> </ul> <p>Sanitizer signature: <pre><code>// Input: raw field data and a type-erased field pointer\n// Output: success via bool return value\n//         sanitized value written to `out` of type T\ntemplate&lt;typename T&gt;\nusing SanitizerFn = bool (*)(std::string_view input, const void* fieldPtr, T&amp; out);\n</code></pre></p>"},{"location":"api_reference/forms/#custom_1","title":"Custom","text":"<p>Custom rules must explicitly provide validation and sanitization logic. Only the minimum theory required to implement them correctly is covered here.</p> <p>A custom rule must expose:</p> <ul> <li>A validator (<code>ValidatorFn</code>)</li> <li>A sanitizer (<code>SanitizerFn&lt;T&gt;</code>)</li> <li>Dispatcher overloads for both</li> <li>A <code>DecayedType</code> mapping to the final C++ type</li> </ul> <p>Example (Defining custom rules): <pre><code>#include &lt;form/forms.hpp&gt;\n#include &lt;cctype&gt;\n#include &lt;charconv&gt;\n\n// Custom Rule\nstruct HexUInt : Form::BaseRule {\n    std::uint64_t max = UINT64_MAX;\n};\n\n// Decayed Type\ntemplate&lt;&gt;\nstruct Form::DecayedType&lt;HexUInt&gt; {\n    using Type = std::uint64_t;\n};\n\n// Validator: Checks that the input is a valid hexadecimal string\nstatic inline bool ValidateHexUInt( // Must follow validator signature\n    std::string_view sv,\n    const void* fieldPtr\n) {\n    const HexUInt&amp; r = *static_cast&lt;const HexUInt*&gt;(fieldPtr);\n\n    if(sv.empty())\n        return false;\n\n    for(char c : sv) {\n        if(!std::isxdigit(static_cast&lt;unsigned char&gt;(c)))\n            return false;\n    }\n\n    return true;\n}\n\n// Validator Dispatcher\nstatic constexpr Form::ValidatorFn DefaultValidatorFor(const HexUInt&amp;)\n{\n    return ValidateHexUInt;\n}\n\n// Sanitizer: Performs the actual conversion and range checking\nstatic inline bool SanitizeHexUInt( // Must follow sanitizer signature\n    std::string_view sv,\n    const void* fieldPtr,\n    std::uint64_t&amp; out              // Here 'T' is our decayed type\n) {\n    const HexUInt&amp; r = *static_cast&lt;const HexUInt*&gt;(fieldPtr);\n\n    std::uint64_t value = 0;\n    auto [ptr, ec] = std::from_chars(\n        sv.data(), sv.data() + sv.size(), value, 16\n    );\n\n    if(ec != std::errc{})\n        return false;\n\n    if(value &gt; r.max)\n        return false;\n\n    out = value;\n    return true;\n}\n\n// Sanitizer Dispatcher\nstatic constexpr\nForm::SanitizerFn&lt;std::uint64_t&gt; DefaultSanitizerFor(const HexUInt&amp;)\n{\n    return SanitizeHexUInt;\n}\n\n// Now your custom rule is ready to be used :)\n</code></pre></p> <p>Tip</p> <ul> <li> <p>You may intentionally skip validation if the same checks would be repeated during sanitization. For example, if sanitization already performs string-to-number conversion and failure detection, duplicating that work in validation is unnecessary.</p> </li> <li> <p>Avoid hardcoding <code>Form::SanitizerFn&lt;std::uint64_t&gt;</code> or <code>std::uint64_t&amp; out</code>. Instead, use <code>Form::SanitizerFn&lt;Form::DecayedType&lt;HexUInt&gt;::Type&gt;</code>. This ensures the sanitizer automatically stays correct if the rule\u2019s output type is changed later, without requiring updates in multiple places.</p> </li> </ul> <p>Example (Overriding default cleanup logic): <pre><code>// Perform parsing and checks in sanitization only\nstatic bool SanitizeEvenInt(\n    std::string_view sv,\n    const void*,\n    std::int64_t&amp; out\n) {\n    auto [ptr, ec] = std::from_chars(\n        sv.data(), sv.data() + sv.size(), out\n    );\n\n    if(ec != std::errc{})\n        return false;\n\n    return (out % 2) == 0;\n}\n\n// ...\nForm::Field(\n    \"count\",\n    Form::Int{ .min = 0, .max = 100 }\n)\n.CustomSanitizer(SanitizeEvenInt);\n// ...\n</code></pre></p>"},{"location":"api_reference/forms/#form-usage","title":"Form Usage","text":"<p>WFX forms can be parsed in multiple ways, depending on how much control you want. If you are unsure which one to use, use <code>Parse</code>.</p>"},{"location":"api_reference/forms/#parse","title":"Parse","text":"<p><code>Parse</code> automatically selects the correct parsing strategy based on the request headers.</p> <p>What it does:</p> <ul> <li>Reads the <code>Content-Type</code> header</li> <li>Chooses the correct parser internally</li> <li>Validates and cleans the form</li> <li>Produces a fully validated output tuple</li> </ul> <p>Current support:</p> <ul> <li><code>application/x-www-form-urlencoded</code></li> </ul> <p>Future support (no code changes required from you):</p> <ul> <li><code>multipart/form-data</code></li> <li>other form encodings</li> </ul> <p>Typical Usage: <pre><code>/*\n * Parses the login form using the 'LoginForm' schema\n *\n * NOTE: 'LoginForm' is assumed to be the one defined in 'Schema' section\n *        of this documentation\n */\nWFX_MIDDLEWARE(\"ParseForm\", [](Request&amp; req, Response res) {\n    if(req.method != HttpMethod::POST)\n        return MiddlewareAction::CONTINUE;\n\n    LoginFormSchema::CleanedType output;\n\n    if(LoginForm.Parse(req, output) != Form::FormError::NONE) {\n        res.Status(HttpStatus::BAD_REQUEST)\n           .SendText(\"Invalid form data\");\n        return MiddlewareAction::BREAK;\n    }\n\n    req.SetContext(\"login-form\", std::move(output));\n    return MiddlewareAction::CONTINUE;\n});\n\n/*\n * The parsed form data is stored as a tuple in the request context\n * Now we can use the stored form as:\n *\n *  // Get the form\n *  auto form = req.GetContext&lt;LoginFormSchema::CleanedType&gt;(\"login-form\");\n *     \n *  // Accesses the first field in declaration order\n *  auto&amp; username = std::get&lt;0&gt;(form);\n */\n</code></pre></p>"},{"location":"api_reference/forms/#parsestatic","title":"ParseStatic","text":"<p><code>ParseStatic</code> parses a raw form body directly. It does not look at headers and does not guess the format.</p> <p>What it does:</p> <ul> <li>Assumes the body is already <code>application/x-www-form-urlencoded</code> format</li> <li>Parses small, in-memory input</li> <li>Validates and cleans the form</li> </ul> <p>Typical Usage: <pre><code>// Same semantics as the previous example, but the form is parsed directly-\n// -from req.body\n//\n// In a real application, you should perform basic sanity checks yourself,-\n// -such as validating the HTTP method (e.g. POST) and ensuring the-\n// -'Content-Type' header is present and correct.\n\nLoginFormSchema::CleanedType output;\n\nif(LoginForm.ParseStatic(req.body, output) != Form::FormError::NONE) {\n    // Handle failure\n}\n\n// Handle success\n</code></pre></p>"},{"location":"api_reference/forms/#accessing-data","title":"Accessing data","text":"<p>On success, all above mentioned methods produce the same output type.</p> <pre><code>auto&amp; usertype = std::get&lt;0&gt;(output);\nauto&amp; passtype = std::get&lt;1&gt;(output);\n\n// Access value via .value member (More information below)\nstd::string_view username = usertype.value;\n</code></pre> <ul> <li>Access is positional (0-based indexing), based on field definition order</li> <li>Output is valid only if parsing succeeded</li> </ul> <p>Field value semantics (important)</p> <p>Each extracted element (e.g. <code>username</code>, <code>password</code>) is not a raw type. It is a cleaned type wrapper struct with the following members:</p> <pre><code>field.value\nfield.present\n</code></pre> <ul> <li> <p><code>.value</code> </p> <ul> <li>Holds the parsed and validated value</li> <li>Type is the decayed field type (after sanitization / normalization)</li> <li>Safe to read only if parsing succeeded</li> </ul> </li> <li> <p><code>.present</code> </p> <ul> <li>Indicates whether the field was actually provided in the input</li> <li>Meaningful only for optional fields (<code>.required = false</code>)</li> <li> <p>Semantics:  </p> <ul> <li><code>true</code> -&gt; field was present and parsed</li> <li><code>false</code> -&gt; field was omitted by the user</li> </ul> </li> <li> <p>For required fields, <code>.present</code> is always <code>true</code> on successful parsing</p> </li> </ul> </li> </ul>"},{"location":"api_reference/forms/#form-rendering","title":"Form Rendering","text":"<p>WFX provides field-level rendering only.</p> <p>What Is Rendered</p> <p>Each form schema pre-renders its fields at construction time.</p> <pre><code>std::string_view html = LoginForm.Render();\n</code></pre> <p><code>Render()</code> returns a view to HTML containing:</p> <ul> <li><code>&lt;label&gt;</code> elements</li> <li><code>&lt;input&gt;</code> elements</li> <li>One pair per field</li> <li>In the exact order the fields were defined</li> </ul> <p>The output is static, pre-built, and allocation-free at render time.</p> <p>What Is Not Rendered</p> <p>WFX does not generate:</p> <ul> <li><code>&lt;form&gt;</code> tags</li> <li>Submit buttons</li> <li>Custom attributes</li> <li>Layout or styling</li> </ul> <p>These are always the responsibility of the user.</p> <p>Typical Usage</p> <p>HTML Template: <pre><code>&lt;!-- ... --&gt;\n  &lt;form class=\"login-form\" method=\"POST\"&gt;\n    {% var login_form_fields %}\n\n    &lt;button type=\"submit\" class=\"btn-enquire\"&gt;\n      Enquire Now\n    &lt;/button&gt;\n  &lt;/form&gt;\n&lt;!-- ... --&gt;\n</code></pre></p> <p>C++ Source Code: <pre><code>// There are two supported ways to pass rendered form fields to templates:\n//\n// 1. Using Render()\n//    - Returns a pre-rendered HTML string_view\n//    - Simple and straightforward\n//\n// 2. Using FormToJson()\n//    - Avoids an extra copy / allocation\n//    - Technically more efficient\n//\nWFX_GET(\"/form\", [](Request&amp; req, Response res) {\n    res.SendTemplate(\"login-page.html\", Json::object({\n        { \"login_form_fields\", LoginForm.Render() }\n        /* ... */\n    }));\n});\n\n// Same result as above, but more optimized\nWFX_GET(\"/form\", [](Request&amp; req, Response res) {\n    res.SendTemplate(\"login-page.html\", Json::object({\n        { \"login_form_fields\", Form::FormToJson(LoginForm) }\n        /* ... */\n    }));\n});\n</code></pre></p> <p>Rendered HTML: <pre><code>&lt;!-- ... --&gt;\n  &lt;form class=\"login-form\" method=\"POST\"&gt;\n    &lt;label for=\"login__username\"&gt;username&lt;/label&gt;\n    &lt;input\n        id=\"login__username\"\n        name=\"username\"\n        type=\"text\"\n        maxlength=\"64\"\n        pattern=\"[\\x20-\\x7E]*\"\n    /&gt;\n\n    &lt;label for=\"login__password\"&gt;password&lt;/label&gt;\n    &lt;input\n        id=\"login__password\"\n        name=\"password\"\n        type=\"text\"\n        minlength=\"6\"\n        maxlength=\"64\"\n        pattern=\"[\\x20-\\x7E]*\"\n    /&gt;\n\n    &lt;button type=\"submit\" class=\"btn-enquire\"&gt;\n      Enquire Now\n    &lt;/button&gt;\n  &lt;/form&gt;\n&lt;!-- ... --&gt;\n</code></pre></p> <p>Important</p> <p>Design notes and guarantees</p> <ul> <li> <p>WFX intentionally renders only form fields (labels and inputs), not the <code>&lt;form&gt;</code> element itself. This is by design, so you retain full control over CSRF tokens, honeypots, submit buttons, layout, and any additional markup outside the fields.</p> </li> <li> <p>Every rendered input uses a stable and predictable <code>id</code> format: <code>&lt;form-schema-name&gt;__&lt;field-name&gt;</code> This guarantees uniqueness across forms and allows reliable label association and client-side scripting without collisions.</p> </li> </ul> <p>Warning</p> <p>WFX currently does not validate global uniqueness of form schema names.</p> <p>This means the following is allowed but incorrect:</p> <pre><code>inline const auto LoginForm  = Form::FormSchema{ \"login\",  /* ... */ };\ninline const auto SigninForm = Form::FormSchema{ \"login\",  /* ... */ };\n</code></pre> <p>Since rendered input IDs are generated using the format <code>&lt;form-schema-name&gt;__&lt;field-name&gt;</code>, both schemas above will produce colliding <code>id</code> attributes in the generated HTML.</p> <p>Consequences include:</p> <ul> <li>Broken <code>&lt;label for=\"...\"&gt;</code> associations</li> <li>Undefined behavior in client-side scripts</li> <li>Hard-to-debug rendering issues</li> </ul> <p>Until explicit collision checks are added, it is your responsibility to ensure all form schema names are globally unique.</p>"},{"location":"api_reference/middleware/","title":"Middleware","text":"<p>Middleware in WFX provides a mechanism to intercept and control request processing before a route handler may be invoked, including the ability to short-circuit execution entirely. Typical use cases include authentication, authorization, logging, request preprocessing, and early rejection of requests.</p> <p>Middleware can be registered globally or per-route. This page documents both sync and async middleware.</p> <p>Important</p> <p>Middleware requires the user to always include the following header at the top of the file: <pre><code>#include &lt;http/middleware.hpp&gt;\n</code></pre></p>"},{"location":"api_reference/middleware/#middleware-return-value","title":"Middleware Return Value","text":"<p>Every middleware in WFX must return a value that determines how request processing continues. This return value is represented by the <code>MiddlewareAction</code> enum and is common to all middleware, regardless of where it is used.</p> <pre><code>enum class MiddlewareAction : std::uint8_t {\n    CONTINUE,\n    BREAK,\n    SKIP_NEXT\n};\n</code></pre> <p>Action Semantics:</p> <ul> <li> <p><code>CONTINUE</code>     Proceeds to the next middleware in the chain. If no middleware remains, request handling continues to the user route handler.</p> </li> <li> <p><code>BREAK</code>     Terminates middleware execution immediately. No further middleware or route handler will be executed.</p> </li> <li> <p><code>SKIP_NEXT</code>     Skips the immediately following middleware in the chain, if one exists.     If the current middleware is <code>A</code>, the next middleware <code>B</code> is skipped and execution continues with <code>C</code> (if present).     If there is no next middleware to skip, execution continues normally.</p> </li> </ul>"},{"location":"api_reference/middleware/#basic-middleware","title":"Basic Middleware","text":"<p>Middleware must be registered before it can be used by any route. Registration is done using macros and follows the same deferred initialization model as routes.</p> <p>Example:</p> <pre><code>// Using a lambda\nWFX_MIDDLEWARE(\"auth\", [](Request&amp; req, Response res) {\n    /* ... */\n    return MiddlewareAction::CONTINUE; // mandatory\n});\n\n// Using a function\nMiddlewareAction AuthMiddleware(Request&amp; req, Response res)\n{\n    /* ... */\n    return MiddlewareAction::CONTINUE; // mandatory\n}\n\nWFX_MIDDLEWARE(\"auth\", AuthMiddleware);\n</code></pre> <p>The above code:</p> <ul> <li>Registers a middleware under a string identifier.</li> <li>Registration occurs during static initialization and is finalized at engine startup.</li> <li>The name is used to define the execution order of middleware via the <code>[Project] middleware_list</code> section in <code>wfx.toml</code>.</li> </ul> <p>Note</p> <p>Middleware registration and configuration follow these rules:</p> <ol> <li> <p>If a middleware is defined in user code but not listed in <code>[Project] middleware_list</code>, it is treated as dead code and will never execute. No warning or error is currently emitted. This is a known limitation and should be considered a bug.</p> </li> <li> <p>If a middleware name is listed in <code>[Project] middleware_list</code> but no corresponding middleware is registered in user code, the server will fail to start with a fatal error.</p> </li> <li> <p>Middleware names must be unique:</p> <ul> <li>Duplicate names in <code>[Project] middleware_list</code> result in a fatal error.</li> <li>Duplicate middleware registrations in user code also result in a fatal error.</li> </ul> </li> <li> <p>Middleware executes strictly in the order specified in <code>[Project] middleware_list</code>.</p> </li> </ol>"},{"location":"api_reference/middleware/#async-middleware","title":"Async Middleware","text":"<p>Async middleware allows middleware logic to suspend execution without blocking the event loop. This is intended for operations that may suspend execution, such as time-based delays, I/O-bound work (database queries, external API calls), rate limiting, or deferred validation logic. Async middleware follows the same registration, ordering, and return semantics as synchronous middleware. The only difference is that execution occurs inside a coroutine.</p> <p>Example: <pre><code>/*\n * NOTE: This header is mandatory when using any builtin async utilities-\n *       -such as functions like 'SleepFor'. It also brings in the core-\n *       -async machinery, including 'AsyncMiddlewareAction' and related types\n */\n#include &lt;async/builtins.hpp&gt;\n\nWFX_MIDDLEWARE(\"RequestCooldown\", [](Request&amp; _, Response res) -&gt; AsyncMiddlewareAction {\n    auto err = co_await Async::SleepFor(2000);\n\n    if(err != Async::Status::NONE) {\n        res.Status(HttpStatus::INTERNAL_SERVER_ERROR)\n            .SendText(\"Middleware Failed to sleep for 2 seconds :(\");\n\n        co_return MiddlewareAction::BREAK;\n    }\n\n    co_return MiddlewareAction::CONTINUE;\n})\n</code></pre></p> <p>Tip</p> <p>For a deeper understanding of how builtin coroutines work in WFX, see the Async page.</p>"},{"location":"api_reference/overview/","title":"Overview","text":"<p>This page documents the public WFX API.</p> <p>It defines how users are expected to interact with the engine at the source level, what guarantees are provided, and what guarantees are explicitly not provided. Anything not documented here is not part of the public API and may change, break, or be removed without notice.</p> <p>Before using any API, it is important to understand the fundamental design decisions and constraints of WFX.</p>"},{"location":"api_reference/overview/#stability-status-important","title":"Stability Status (Important)","text":"<p>WFX is under active development.</p>"},{"location":"api_reference/overview/#api-stability","title":"API Stability","text":"<ul> <li>Not guaranteed at this stage</li> <li>Public APIs may change as the engine evolves</li> <li>Breaking changes are expected until the first official stable release on the <code>main</code> branch</li> </ul>"},{"location":"api_reference/overview/#abi-stability","title":"ABI Stability","text":"<ul> <li>Not guaranteed at this stage</li> <li>No effort is currently made to preserve binary compatibility</li> <li>Engine and application must be built with matching toolchains and headers</li> </ul> <p>Note</p> <p>ABI stability may be introduced in the future, but no guarantees are made at this time.</p>"},{"location":"api_reference/overview/#execution-model","title":"Execution Model","text":"<p>WFX follows a synchronous execution model.</p> <p>This refers to the order in which engine logic executes and how control flows through the system. Even when using asynchronous APIs, execution order is deterministic and controlled by the engine. Asynchronous operations do not imply arbitrary or parallel execution of user code.</p> <p>Users should assume that callbacks and async-related APIs still execute within a well-defined engine-controlled flow.</p>"},{"location":"api_reference/overview/#error-handling-and-misuse","title":"Error Handling and Misuse","text":"<p>Not all APIs are guarded by runtime checks.</p> <p>Some APIs perform internal validation and will fail loudly if misused. Depending on the API, misuse may cause the engine to terminate via a fatal error or result in the operation failing silently with an error logged.</p> <p>Other APIs assume correct usage and provide little to no protection against invalid input or incorrect call order.</p> <p>These runtime checks are meant to catch developer mistakes, not to sanitize or validate external input. Data coming from outside the engine (network requests, files, etc.) is always properly error-checked and handled separately.</p> <p>The expectation is that users do not attempt random or undefined usage patterns. If an API is documented with constraints, those constraints are mandatory.</p>"},{"location":"api_reference/overview/#scope-of-the-api-reference","title":"Scope of the API Reference","text":"<p>This API reference documents only the public surface of WFX.</p> <p>Internal systems, internal headers, undocumented behavior, and implementation details are intentionally excluded. Relying on internal behavior or undocumented side effects is unsupported and unsafe.</p> <p>If a feature or behavior is not documented here, it should be treated as non-existent from a public API perspective.</p>"},{"location":"api_reference/overview/#updates-and-versioning","title":"Updates and Versioning","text":"<p>The primary focus is establishing a stable and consistent API surface.</p> <p>Right now WFX is under active development. Bug fixes, internal changes, and performance improvements may happen at any time. These changes may break source compatibility with previous builds, and binary compatibility is not considered.</p> <p>In future updates, tracking versions and updates will be easier, as automatic update checks and notifications will be added. For now, users are expected to manually track releases and recompile their code against the current version of WFX.</p>"},{"location":"api_reference/overview/#getting-started-with-the-api-reference","title":"Getting Started with the API Reference","text":"<p>WFX API reference is organized into sections: Request &amp; Response, Routing &amp; Grouping, Middleware, and Constructors.</p> <ul> <li>If you are new to WFX, it is recommended to follow the sections in order, from Request &amp; Response first, then Routing, and so on. This will give you a proper understanding of how the engine works and how components interact.  </li> <li>If you are an experienced user or looking for a specific API, you can jump directly to the section of interest. All sections are self-contained, so you can refer to them independently.  </li> </ul>"},{"location":"api_reference/request_and_response/","title":"Request &amp; Response","text":"<p>Understanding how requests and responses work is fundamental to using WFX effectively. This page covers the types and methods you will interact with in user code.</p>"},{"location":"api_reference/request_and_response/#request","title":"Request","text":"<p><code>Request</code> represents an incoming HTTP request. It contains all data associated with the request lifecycle, including metadata, headers, body, and parsed path information. It also exposes a per-request context store that can be used to share data between middleware, routes, and user code.</p> <p>Note</p> <p>Although the underlying type is <code>HttpRequest</code>, it is internally aliased to <code>Request</code> for user-facing APIs. This is done intentionally to mirror <code>Response</code>, which is also a user-side abstraction, and to keep request and response usage consistent in user code.</p> <p>Below are the primary members exposed by the <code>Request</code> structure.</p> <ul> <li> <p><code>method</code> - <code>HttpMethod</code>     Represents the HTTP method of the request (<code>GET</code>, <code>POST</code>, etc.). Read-only, set by the engine.  </p> <pre><code>if(req.method == HttpMethod::GET) { /* handle GET */ }\n</code></pre> </li> <li> <p><code>version</code> - <code>HttpVersion</code>     HTTP version (<code>HTTP_1_0</code>, <code>HTTP_1_1</code>, <code>HTTP_2_0</code>, etc.). Read-only, set by the engine.</p> <pre><code>if(req.version == HttpVersion::HTTP_1_1) { /* handle HTTP/1.1 */ }\n</code></pre> </li> <li> <p><code>path</code> - <code>std::string_view</code>     The requested path as a view into the request buffer.     Essentially read-only, but can be modified under controlled circumstances as long as you do not exceed the original size. Do not retain references beyond the request lifecycle.</p> <pre><code>if(req.path == \"/login\") { /* handle login */ }\n</code></pre> </li> <li> <p><code>body</code> - <code>std::string_view</code>     Raw request body. For POST/PUT requests, contains the payload.     Essentially read-only, but can be modified in place as long as you do not exceed the buffer size.</p> <pre><code>auto data = std::string(req.body); // copy if you need to keep it\n</code></pre> </li> <li> <p><code>headers</code> - <code>std::unordered_map&lt;std::string_view, std::string_view&gt;</code>     Represents HTTP headers. Provides lookup and iteration.</p> <pre><code>// 'GetHeader' returns an empty std::string_view if not found\nauto ua = req.headers.GetHeader(\"User-Agent\");\nprintf(\"User-Agent: %.*s\\n\", (int)ua.size(), ua.data());\n\n// You can also use 'CheckAndGetHeader' to get a pair {exists?, value}\nauto [exists, token] = req.headers.CheckAndGetHeader(\"X-Token\");\nif(!exists) { /* handle error */ }\nelse        { /* handle token */ }\n\n// Or you can set header, unlikely but possible via 'SetHeader'\nreq.headers.SetHeader(\"My-Value\", \"WFX\");\n</code></pre> </li> <li> <p><code>pathSegments</code> - <code>std::vector&lt;std::variant&lt;...&gt;&gt;</code>     Contains the parsed components of the request path. Each segment represents either a literal path component or a typed route parameter extracted from the URL (for example integers or UUIDs).</p> <p>This allows route handlers to access route parameters in a type-safe manner without performing manual string parsing or conversions.</p> <p>Example route: <pre><code>WFX_GET(\"/users/&lt;int&gt;/posts/&lt;uint&gt;\", [](Request&amp; req, Respons&amp; res) {\n    /* ... */\n});\n</code></pre></p> <p>Incoming request: <code>/users/42/posts/100</code></p> <p>Conceptual internal representation: <pre><code>[\n    int64_t{42},\n    uint64_t{100}\n]\n</code></pre></p> <p>Accessing values manually: <pre><code>auto userId = std::get&lt;int64_t&gt;(req.pathSegments[0]);\nauto postId = std::get&lt;uint64_t&gt;(req.pathSegments[1]);\n</code></pre></p> <p>Accessing values using segment macros: <pre><code>auto userId = GetSegmentAsInt(req.pathSegments[0]);\nauto postId = GetSegmentAsUInt(req.pathSegments[1]);\n</code></pre></p> <p>Note</p> <p>The purpose and usage of <code>pathSegments</code> will become much clearer in the Routing section.</p> </li> <li> <p><code>context</code> - <code>std::unordered_map&lt;std::string, std::any&gt;</code>     Allows storing arbitrary values for the lifetime of the request. It is useful for passing data between middleware and route handlers.</p> <pre><code>// Store a value\nreq.SetContext&lt;int&gt;(\"user_id\", 42);\n\n// Retrieve a value (returns pointer to value if it exists, else nullptr)\nif(auto id = req.GetContext&lt;int&gt;(\"user_id\")) {\n    printf(\"User ID: %d\\n\", *id);\n}\n\n// Initialize or get value\nauto* ptr = req.InitOrGetContext&lt;std::string&gt;(\"session\", \"default_session\");\n</code></pre> <p>Tip</p> <p>While the context map is flexible, it is not cheap. Each entry involves a hash lookup, a std::string key, and a std::any allocation. Avoid storing large objects or excessive transient data in the context. Prefer storing small, well-defined values that are genuinely needed across middleware and handlers. Overusing the context can negatively impact performance and cache locality.</p> </li> </ul>"},{"location":"api_reference/request_and_response/#response","title":"Response","text":"<p><code>Response</code> represents the outgoing HTTP response. It is the primary interface used by application code to control status codes, headers, and the response body sent back to the client.</p> <p>It is a user-facing abstraction: internally, all operations are forwarded to the engine via provided APIs. Users never interact directly with the underlying response implementation.</p> <p>Note</p> <p><code>Response</code> does not own the underlying response object and internally holds pointers to engine-managed state.</p> <p>In synchronous routes, the <code>Response</code> instance is guaranteed to be valid for the entire duration of the user callback.</p> <p>In asynchronous routes, this guarantee no longer holds once execution yields. If an async operation needs to continue using the response after yielding, the response state must be explicitly copied. This is required because the underlying HTTP response object is only guaranteed to exist while the connection is alive and under engine control.</p> <p>This pattern is not recommended and should only be used when absolutely necessary. Prefer designing async logic such that the response is finalized within the intended execution scope.</p> <p>Danger</p> <p>All send and stream operations are single-use per request\u2013response lifecycle.</p> <p>Any <code>Send*</code> or <code>Stream*</code> function must be called exactly once during a single request\u2013response cycle. Calling any send or stream function again within the same cycle is fatal and will terminate the engine.</p> <p>After the request\u2013response lifecycle completes, if the connection is still alive, the engine will automatically reset its internal state, allowing send/stream operations to be used again for the next cycle.</p> <p>Below are the primary methods exposed by <code>Response</code>.</p> <ul> <li> <p><code>Status(HttpStatus code)</code>     Sets the HTTP status code for the response.</p> <p>Returns a reference to <code>Response</code> to allow chaining.</p> <p>Without chaining: <pre><code>res.Status(HttpStatus::OK);\nres.Set(\"Location\", \"/users/42\");\n</code></pre></p> <p>With chaining: <pre><code>res.Status(HttpStatus::CREATED)\n    .Set(\"Location\", \"/users/42\");\n</code></pre></p> </li> <li> <p><code>Set(std::string key, std::string value)</code>     Sets or overrides an HTTP response header.     Both key and value are moved into the response. Header names are treated as-is.  </p> <p>Returns a reference to <code>Response</code> to allow chaining.</p> <p>Without chaining: <pre><code>res.Set(\"Content-Type\", \"application/json\");\nres.Set(\"X-Powered-By\", \"WFX\");\n</code></pre></p> <p>With chaining: <pre><code>res.Set(\"Content-Type\", \"application/json\")\n    .Set(\"X-Powered-By\", \"WFX\");\n</code></pre></p> </li> <li> <p><code>SendText(...)</code>     Sends a plain text response body. The appropriate content type (<code>text/plain</code>) is set internally.</p> <p>Overloads:</p> <ul> <li><code>SendText(const char* cstr)</code></li> <li><code>SendText(std::string&amp;&amp; str)</code></li> </ul> <p>Example: <pre><code>// Uses const char* overload\nres.SendText(\"Hello from WFX\");\n\n// Uses std::string overload\nres.SendText(std::string(\"Dynamic response\"));\n</code></pre></p> </li> <li> <p><code>SendJson(const Json&amp; j)</code>     Sends a JSON response. The appropriate content type (<code>application/json</code>) is set internally.</p> <p>Example: <pre><code>res.SendJson(Json::object({\n    {\"status\", \"ok\"},\n    {\"value\", 42}\n}));\n</code></pre></p> </li> <li> <p><code>SendFile(...)</code>     Sends a file from disk as the response body. The appropriate content type is handled internally (based on file extension).</p> <p>Overloads:</p> <ul> <li><code>SendFile(const char* path, bool autoHandle404 = true)</code></li> <li><code>SendFile(std::string&amp;&amp; path, bool autoHandle404 = true)</code></li> </ul> <p>If <code>autoHandle404</code> is enabled and the file does not exist, the engine will automatically handle the error response. If <code>autoHandle404</code> is disabled and the file does not exist, the networking backend will handle the situation as a fallback. However, this is not recommended, as it is intended only to prevent undefined behavior or server crashes, not as a primary error-handling mechanism.</p> <p>Example: <pre><code>// Uses const char* overload\nres.SendFile(\"static/index.html\");\n</code></pre></p> <p>Important</p> <p>The provided path must be either:</p> <ul> <li>an absolute path, or</li> <li>a path relative to the engine's working directory.</li> </ul> <p>Relative paths are resolved against the engine location itself, not the caller's source file or project root.</p> </li> <li> <p><code>SendTemplate(...)</code>     Renders and sends a template. The appropriate content type (<code>text/html</code>) is set internally.</p> <p>Overloads:</p> <ul> <li><code>SendTemplate(const char* path, Json&amp;&amp; ctx = {})</code></li> <li><code>SendTemplate(std::string&amp;&amp; path, Json&amp;&amp; ctx = {})</code></li> </ul> <p>The optional JSON context is provided to the template renderer to populate dynamic content. If the specified template cannot be found, the engine will automatically send a 404 Template Not Found response.</p> <p>Example: <pre><code>// Uses const char* overload + no JSON context provided (static template)\nres.SendTemplate(\"index.html\");\n\n// Uses const char* overload + JSON context provied (dynamic template)\nres.SendTemplate(\"profile.html\", Json::object({\n    {\"username\", \"atomic\"},\n    {\"id\", 42}\n}));\n</code></pre></p> <p>Tip</p> <p>For detailed information about template syntax, compilation, rendering modes, and data binding, see the Templates section.</p> </li> <li> <p><code>Stream(StreamGenerator generator, bool streamChunked = true)</code>     Initiates a streaming response. The provided generator is repeatedly called by the networking backend whenever it is ready to accept more data. This allows incremental or large responses to be sent without buffering the entire payload in memory.</p> <p>Important: <code>Stream</code> does not set <code>Content-Type</code> header internally.</p> <p>Definitions: <pre><code>enum class StreamAction {\n    CONTINUE,             // Continue streaming\n    STOP_AND_ALIVE_CONN,  // Stop streaming and keep the connection alive\n    STOP_AND_CLOSE_CONN   // Stop streaming and close the connection\n};\n\nstruct StreamResult {\n    std::size_t  writtenBytes; // Number of bytes written into buffer\n    StreamAction action;       // Action to take after this invocation\n};\n\nstruct StreamBuffer {\n    char*       buffer; // Writable buffer provided by the engine\n    std::size_t size;   // Size of the buffer in bytes\n};\n\n// Streaming generator signature\nusing StreamGenerator = MoveOnlyFunction&lt;StreamResult(StreamBuffer)&gt;;\n</code></pre></p> <p>Example: <pre><code>// Streaming a file-like source\nres.Stream([\n    offset = std::size_t{0}\n](StreamBuffer buffer) mutable {\n    std::size_t bytes = ReadFromSource(offset, buffer.buffer, buffer.size);\n\n    // End of data\n    // Stop streaming and keep the connection alive\n    if(bytes == 0) {\n        return StreamResult{\n            0,\n            StreamAction::STOP_AND_ALIVE_CONN\n        };\n    }\n\n    // Continue streaming for more data\n    offset += bytes;\n    return StreamResult{\n        bytes,\n        StreamAction::CONTINUE\n    };\n}, false);\n</code></pre></p> <p>Note</p> <ul> <li>Streaming generators are executed under the engine's control. They are invoked only when the networking backend is ready to send data. This model avoids buffering entire responses in memory and provides explicit control over connection lifetime.</li> <li>Buffer capacity is controlled by the <code>[Network] send_buffer_max</code> value in <code>wfx.toml</code>.</li> </ul> </li> </ul>"},{"location":"api_reference/routing/","title":"Routing","text":"<p>WFX provides a macro-based routing system that allows registering request handlers in a declarative manner. Routes are automatically registered during program initialization through deferred execution, ensuring deterministic order and avoiding manual registration.  </p> <p>This page covers both sync and async routes.</p> <p>Important</p> <p>Routing requires the user to always include the routing header at the top of the file: <pre><code>#include &lt;http/routes.hpp&gt;\n</code></pre></p> <p>Danger</p> <ul> <li> <p>The <code>path</code> argument in route and group macros must refer to a string that remains valid for the lifetime of the program. Using a temporary or short-lived string (e.g., a locally created <code>std::string</code>) will cause undefined behavior and may crash the server.</p> </li> <li> <p>Routes defined by the developer are not fully validated by WFX. While incoming request paths are normalized and checked thoroughly, WFX does not validate the route definitions themselves. Defining unsafe or nonsensical paths (e.g., containing <code>../..</code>) can lead to undefined behavior. Ensure all route paths are correctly and safely specified.</p> </li> </ul>"},{"location":"api_reference/routing/#basic-routes","title":"Basic Routes","text":"<p>Routes are defined using method-specific macros:</p> <pre><code>WFX_GET(\"/health\", [](Request&amp; req, Response res) {\n    res.SendText(\"OK\");\n});\n\nWFX_POST(\"/login\", [](Request&amp; req, Response res) {\n    // Handle login request\n});\n</code></pre> <p><code>WFX_GET(path, handler)</code> / <code>WFX_POST(path, handler)</code> - macros corresponding to HTTP methods.</p> <ul> <li><code>path</code> - the route path as a string literal. Supports dynamic segments (see below).</li> <li><code>handler</code> - a callable object or lambda with signature <code>void(Request&amp;, Response)</code>.</li> </ul>"},{"location":"api_reference/routing/#route-groups","title":"Route Groups","text":"<p>Route groups allow applying a common prefix to multiple routes:</p> <pre><code>WFX_GROUP_START(\"/api\")\n\n    WFX_GET(\"/users\", [](Request&amp; req, Response res) {\n        // List users\n    });\n\n    WFX_POST(\"/users\", [](Request&amp; req, Response res) {\n        // Create user\n    });\n\nWFX_GROUP_END()\n\n// Now the routes for GET and POST become /api/users\n</code></pre> <p><code>WFX_GROUP_START(path)</code> - pushes a prefix (<code>path</code>) to all routes within the group. <code>WFX_GROUP_END()</code> - pops the last pushed prefix.</p> <p>Groups may be nested to form hierarchical route structures.</p> <p>Warning</p> <p>Each <code>WFX_GROUP_START</code> must be paired with a corresponding <code>WFX_GROUP_END</code>. If the number of start and end macros does not match, the server will fail to start and terminate with an error.</p>"},{"location":"api_reference/routing/#dynamic-path-segments","title":"Dynamic Path Segments","text":"<p>Routes can include dynamic segments that extract values from the URL. A segment can optionally have a name before the colon (<code>:</code>) for readability, but the name is not required. The engine only uses the segment type for parsing and indexing.</p> <p>Helper Macro:</p> <p>WFX provides helper macros to simplify access to dynamic path segments, but all of these operations can also be done manually if needed. The macros are essentially shortcuts for extracting and converting segments.</p> Macro Equivalent Manual Access <code>GetSegmentAsString(segment)</code> <code>std::get&lt;std::string_view&gt;(segment)</code> <code>GetSegmentAsInt(segment)</code> <code>std::get&lt;int64_t&gt;(segment)</code> <code>GetSegmentAsUInt(segment)</code> <code>std::get&lt;uint64_t&gt;(segment)</code> <code>GetSegmentAsUUID(segment)</code> <code>std::get&lt;WFX::Utils::UUID&gt;(segment)</code> <p>Segment Indexing:</p> <p>Segments are indexed in the order they appear, starting from 0.</p> <p>Example with multiple segments:</p> <pre><code>WFX_GET(\"/user/&lt;id:int&gt;/posts/&lt;pid:int&gt;\", [](Request&amp; req, Response res) {\n    int64_t userId = GetSegmentAsInt(req.pathSegments[0]);\n    int64_t postId = GetSegmentAsInt(req.pathSegments[1]);\n});\n</code></pre> <p>Note</p> <ul> <li>Out-of-bounds access is not checked by WFX. Attempting to read a segment index that does not exist will cause undefined behavior. Developers are responsible for ensuring segment indices are correct.</li> <li>Accessing a <code>/&lt;int&gt;</code> path segment using an incompatible type will cause <code>std::get&lt;&gt;</code> to throw an exception. Always extract segments using the correct helper for their declared type (e.g., do not read an <code>int</code> segment as <code>uint</code> or <code>UUID</code>). Failing to do so results in unnecessary exceptions and, if unhandled, may crash the server.</li> </ul> <p>Supported Segment Types:</p> Segment Type Helper Macro Return Type int <code>GetSegmentAsInt(segment)</code> int64_t uint <code>GetSegmentAsUInt(segment)</code> uint64_t string <code>GetSegmentAsString(segment)</code> std::string_view uuid <code>GetSegmentAsUUID(segment)</code> WFX::Utils::UUID <p>Example: <pre><code>// Named segment\nWFX_GET(\"/user/&lt;id:int&gt;\", [](Request&amp; req, Response res) {\n    int64_t userId = GetSegmentAsInt(req.pathSegments[0]);\n});\n\n// Unnamed segment (also valid) + manual access\nWFX_GET(\"/user/&lt;int&gt;\", [](Request&amp; req, Response res) {\n    int64_t userId = std::get&lt;int64_t&gt;(req.pathSegments[0]);\n});\n</code></pre></p> <ul> <li><code>&lt;id:int&gt;</code> - id is optional; used as a comment for developer understanding.</li> <li><code>&lt;int&gt;</code> - valid, same as above but without a name.</li> </ul>"},{"location":"api_reference/routing/#routes-with-middleware","title":"Routes with Middleware","text":"<p>WFX allows routes to execute middleware before the main handler. Middleware can perform tasks such as authentication, logging, or input validation. Each route can have its own middleware stack, which is executed in order before the route handler is called.</p> <p>Key Points:</p> <ul> <li>Middleware must be provided either via <code>WFX_MW_LIST</code> or using <code>MakeMiddlewareFromFunctions</code>.  </li> <li>Even if the route uses only a single middleware function, it must be wrapped with one of these helpers.  </li> <li>The middleware system requires including <code>&lt;http/middleware.hpp&gt;</code> in your source file.</li> </ul> <p>Example:</p> <pre><code>#include &lt;http/middleware.hpp&gt;\n\n// 'AuthMiddleware' and 'SecurityMiddleware' is applied only to this route\n// It does not affect other routes\nWFX_GET_EX(\n    \"/secure\",\n    WFX_MW_LIST(AuthMiddleware, SecurityMiddleware, ...),\n    [](Request&amp; req, Response res) { \n        res.SendText(\"Protected content\"); \n    }\n);\n\n// Or\n\nWFX_GET_EX(\n    \"/secure\",\n    MakeMiddlewareFromFunctions(AuthMiddleware, SecurityMiddleware, ...),\n    [](Request&amp; req, Response res) { \n        res.SendText(\"Protected content\"); \n    }\n);\n</code></pre>"},{"location":"api_reference/routing/#async-routes","title":"Async Routes","text":"<p>WFX routes can be declared async by returning an async task type (e.g. <code>AsyncVoid</code>). This allows the route handler itself to <code>co_await</code> builtins such as <code>SleepFor</code>, database calls, or other async operations.</p> <p>The signature is identical to a normal route, except the lambda returns an async coroutine type:</p> <pre><code>/*\n * NOTE: This header is mandatory when using any builtin async utilities-\n *       -such as functions like 'SleepFor'. It also brings in the core-\n *       -async machinery, including 'AsyncVoid' and related types\n */\n#include &lt;async/builtins.hpp&gt;\n\nWFX_GET(\"/async\", [](Request&amp; req, Response res) -&gt; AsyncVoid {\n    auto err = co_await Async::SleepFor(2000);\n\n    if(err != Async::Status::NONE)\n        res.SendText(\"Route failed to sleep for 2 seconds :(\");\n    else\n        res.SendText(\"Ok\");\n});\n</code></pre> <p>Tip</p> <p>For a deeper understanding of how builtin coroutines work in WFX, see the Async page.</p>"},{"location":"api_reference/templates/","title":"Templating","text":"<p>WFX includes a simple but high-performance template engine, hereafter referred to as WTX.</p> <p>It is designed for server-side HTML rendering with a strong focus on:</p> <ul> <li>clarity,</li> <li>predictable behavior,</li> <li>and extreme performance in production.</li> </ul>"},{"location":"api_reference/templates/#overview","title":"Overview","text":"<p>WTX operates in two modes:</p>"},{"location":"api_reference/templates/#production-mode","title":"Production mode","text":"<ul> <li>Templates are compiled:<ol> <li>HTML =&gt; bytecode</li> <li>bytecode =&gt; generated C++</li> <li>generated C++ =&gt; shared library (DLL)</li> </ol> </li> <li>The resulting libraries are auto-linked into the engine</li> <li>Templates are cached; files are not reopened repeatedly</li> <li>Rendering is effectively native code execution</li> </ul>"},{"location":"api_reference/templates/#debug-mode","title":"Debug mode","text":"<ul> <li>Templates are still compiled to bytecode</li> <li>Bytecode is interpreted, not converted to C++ / DLL</li> <li>This enables fast iteration without recompilation</li> </ul> <p>Note</p> <p>The debug-mode bytecode interpreter is not implemented yet. The core compilation pipeline is complete; the interpreter is a straightforward addition and will be built later.</p> <p>The template language itself is identical in both modes.</p>"},{"location":"api_reference/templates/#capabilities-and-limits","title":"Capabilities and Limits","text":"<p>Supported constructs:</p> <ul> <li>Variables (<code>var</code>)</li> <li>Logical expressions</li> <li>Conditionals (<code>if</code>, <code>elif</code>, <code>else</code>)</li> <li>Loops (<code>for</code>)</li> <li>Template inheritance (<code>extends</code>)</li> <li>Includes (<code>include</code>)</li> <li>Partials (<code>partial</code>)</li> <li>Named blocks (<code>block</code> / <code>endblock</code>)</li> </ul> <p>Unsupported constructs:</p> <ul> <li>Functions</li> <li>User-defined macros</li> <li>Variable mutation</li> <li>Arbitrary code execution</li> <li>Side effects</li> </ul> <p>This feature set is Django-like, with minor additions (<code>partial</code>, <code>include</code>) for optimization.</p>"},{"location":"api_reference/templates/#sendtemplate","title":"SendTemplate","text":"<p><code>SendTemplate(...)</code> is the core function for sending any HTML template from the <code>templates/</code> folder. All templates (static or dynamic) are sent via this function.</p>"},{"location":"api_reference/templates/#path-resolution","title":"Path resolution","text":"<ul> <li>Paths are relative to the <code>templates/</code> folder.</li> <li>Example:     <pre><code>// templates/index.html exists\nres.SendTemplate(\"index.html\");\n</code></pre></li> </ul>"},{"location":"api_reference/templates/#static-vs-dynamic-templates","title":"Static vs dynamic templates","text":"<p>Whether a template is treated as static or dynamic depends on the constructs it contains:</p> <ul> <li> <p>Static templates:</p> <ul> <li>Contain only <code>include</code>, <code>partial</code>, <code>extends</code>, <code>block</code>, and <code>endblock</code></li> <li>Fully compiled to pre-rendered HTML</li> <li>Sent using zero-copy file send (no JSON context needed)</li> </ul> </li> <li> <p>Dynamic templates:</p> <ul> <li>Contain <code>if</code>, <code>elif</code>, <code>else</code>, <code>endif</code>, <code>for</code>, <code>endfor</code>, or <code>var</code></li> <li>Compiled into DLLs</li> <li>Require the JSON parameter of <code>SendTemplate</code> for runtime data binding</li> </ul> </li> </ul>"},{"location":"api_reference/templates/#constructs","title":"Constructs","text":"<p>This section explains the template language constructs used by WTX. Each construct is shown with a simple template example and the corresponding C++ code that calls <code>SendTemplate</code>.</p>"},{"location":"api_reference/templates/#variables","title":"Variables","text":"<p>Variables must be explicitly declared before they can be used.</p> <p>Template example: <pre><code>&lt;!-- welcome.html --&gt;\n&lt;h1&gt;Welcome&lt;/h1&gt;\n\n&lt;p&gt;\n  Name: {% var name %}\n&lt;/p&gt;\n\n&lt;p&gt;\n  Logged in: {% var logged_in %}\n&lt;/p&gt;\n</code></pre></p> <p>C++ usage: <pre><code>res.SendTemplate(\"welcome.html\", Json::object({\n    {\"name\", \"Alice\"},\n    {\"logged_in\", true}\n}));\n</code></pre></p> <p>Key points:</p> <ul> <li><code>{% var name %}</code> declares the variable name</li> <li>Values are supplied through the JSON context</li> <li>Variable output is HTML-escaped by default</li> </ul> <p>Note</p> <p>If a variable is declared but not present in the JSON context, it is substituted with an empty value (renders as blank).</p>"},{"location":"api_reference/templates/#conditionals","title":"Conditionals","text":"<p>Conditionals control whether a block of HTML is rendered.</p> <p>Template example: <pre><code>&lt;!-- status.html --&gt;\n{% if logged_in &amp;&amp; user.is_verified %}\n  &lt;p&gt;Welcome back, {% var user.name %}.&lt;/p&gt;\n{% elif logged_in %}\n  &lt;p&gt;Your account is not verified.&lt;/p&gt;\n{% else %}\n  &lt;p&gt;Please sign in.&lt;/p&gt;\n{% endif %}\n</code></pre></p> <p>C++ usage: <pre><code>res.SendTemplate(\"status.html\", Json::object({\n    {\n        \"logged_in\", true\n    },\n    {\n        \"user\", Json::object({\n            {\"name\", \"Alice\"},\n            {\"is_verified\", false}\n        })\n    }\n}));\n</code></pre></p> <p>Key points:</p> <ul> <li>Conditions are evaluated at render time</li> <li>No side effects or variable mutation is allowed</li> </ul>"},{"location":"api_reference/templates/#operators","title":"Operators","text":""},{"location":"api_reference/templates/#logical-and-comparision","title":"Logical and Comparision","text":"<p>WTX supports logical and comparison operators. Their behavior matches C++.</p> Operator Meaning <code>&amp;&amp;</code> Logical AND <code>||</code> Logical OR <code>!</code> Logical NOT <code>==</code> Equal <code>!=</code> Not equal <code>&gt;</code> Greater than <code>&gt;=</code> Greater than or equal <code>&lt;</code> Less than <code>&lt;=</code> Less than or equal <p>Template example: <pre><code>{% if logged_in &amp;&amp; age &gt;= 18 %}\n  &lt;p&gt;Access granted.&lt;/p&gt;\n{% endif %}\n</code></pre></p> <p>C++ usage: <pre><code>res.SendTemplate(\"access.html\", Json::object({\n    {\"logged_in\", true},\n    {\"age\", 21}\n}));\n</code></pre></p>"},{"location":"api_reference/templates/#nested-access","title":"Nested access","text":"<p>WTX supports nested access into JSON objects using the dot (<code>.</code>) operator.</p> <p>Template example: <pre><code>{% if user.profile.is_active %}\n  &lt;p&gt;Profile is active.&lt;/p&gt;\n{% endif %}\n\n&lt;p&gt;\n  Email: {% var user.profile.email %}\n&lt;/p&gt;\n</code></pre></p> <p>C++ usage: <pre><code>res.SendTemplate(\"profile.html\", Json::object({\n    {\n        \"user\", Json::object({\n            {\n                \"profile\", Json::object({\n                    {\"is_active\", true},\n                    {\"email\", \"alice@example.com\"}\n                })\n            }\n        })\n    }\n}));\n</code></pre></p> <p>Key points:</p> <ul> <li>Every intermediate segment must resolve to a JSON object; the final segment may be any JSON value.</li> <li>Nested access can be chained (<code>a.b.c</code>)</li> <li>Missing keys result in an empty value</li> <li>Access is read-only; no mutation occurs</li> </ul>"},{"location":"api_reference/templates/#loops","title":"Loops","text":"<p>Loops allow repeated rendering over arrays provided in the JSON context.</p> <p>Template example: <pre><code>&lt;!-- users.html --&gt;\n&lt;h2&gt;Users&lt;/h2&gt;\n\n&lt;ul&gt;\n{% for user in users %}\n  &lt;li&gt;\n    Name: {% var user.name %},\n    Age: {% var user.age %}\n  &lt;/li&gt;\n{% endfor %}\n&lt;/ul&gt;\n</code></pre></p> <p>C++ usage: <pre><code>res.SendTemplate(\"users.html\", Json::object({\n    {\n        \"users\", Json::array({\n            Json::object({\n                {\"name\", \"Alice\"},\n                {\"age\", 21}\n            }),\n            Json::object({\n                {\"name\", \"Bob\"},\n                {\"age\", 30}\n            })\n        })\n    }\n}));\n</code></pre></p> <p>Key points:</p> <ul> <li><code>{% for item in collection %}</code> iterates over a JSON array</li> <li>The loop variable (<code>item</code>) is scoped to the loop body only</li> <li>Each element must be a JSON object to support dotted access</li> <li>Nested loops are allowed</li> <li>If the collection variable does not exist or is not a JSON array,   the loop is not evaluated and the body renders nothing</li> <li>No loop control (<code>break</code>, <code>continue</code>) is supported</li> <li>The collection is read-only; mutation is not possible</li> </ul>"},{"location":"api_reference/templates/#includes","title":"Includes","text":"<p><code>include</code> inserts another template verbatim at compile time.</p> <p>Template example: <pre><code>&lt;!-- base.html --&gt;\n&lt;html&gt;\n  &lt;body&gt;\n    {% include 'header.html' %}\n    &lt;main&gt;\n      &lt;p&gt;Main content&lt;/p&gt;\n    &lt;/main&gt;\n    {% include 'footer.html' %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre></p> <p>Key points:</p> <ul> <li>Included templates cannot receive a separate context</li> <li>Missing include files are a compile-time error</li> <li>Includes are best used for static, reusable fragments</li> </ul>"},{"location":"api_reference/templates/#partials","title":"Partials","text":"<p><code>partial</code> is not a dynamic include. It is a compile-time optimization marker for templates that are never rendered directly.</p> <p>A template marked as <code>partial</code> is intended to be used only as a base (via <code>include</code> or <code>extends</code>) and never sent on its own.</p> <p>Template example: <pre><code>&lt;!-- user_card.html --&gt;\n{% partial %}\n&lt;div class=\"card\"&gt;\n  &lt;p&gt;Name: {% var user.name %}&lt;/p&gt;\n&lt;/div&gt;\n</code></pre> <pre><code>&lt;!-- page.html --&gt;\n&lt;h1&gt;Dashboard&lt;/h1&gt;\n\n{% include 'user_card.html' %}\n</code></pre></p> <p>C++ usage: <pre><code>res.SendTemplate(\"page.html\", Json::object({\n    {\n        \"user\", Json::object({\n            {\"name\", \"Alice\"}\n        })\n    }\n}));\n</code></pre></p> <p>Key points:</p> <ul> <li><code>{% partial %}</code> must be the very first bytes in the file</li> <li>The directive must be written exactly as-is; no whitespace, no BOM, no comments before it</li> <li>Partial templates are never evaluated or rendered as entry-point templates.   This saves some processing time but is purely an optimization</li> <li>Using <code>partial</code> is optional</li> </ul>"},{"location":"api_reference/templates/#inheritance","title":"Inheritance","text":"<p><code>extends</code> enables template inheritance using a base layout at compile time.</p> <p>Template example:</p> <p><pre><code>&lt;!-- base.html --&gt;\n&lt;html&gt;\n  &lt;body&gt;\n    {% block content %}{% endblock %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;!-- home.html --&gt;\n{% extends 'base.html' %}\n\n{% block content %}\n  &lt;h1&gt;Home&lt;/h1&gt;\n  &lt;p&gt;Welcome.&lt;/p&gt;\n{% endblock %}\n</code></pre></p> <p>Key points:</p> <ul> <li><code>extends</code> must appear at the top of the template</li> <li>Only one base template is allowed</li> <li>The base template defines the overall structure</li> <li>Child templates only fill named blocks</li> </ul>"},{"location":"api_reference/templates/#blocks","title":"Blocks","text":"<p>Blocks (<code>block</code> / <code>endblock</code>) define named replacement regions in a base template at compile time.</p> <p>Template example: <pre><code>&lt;!-- layout.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    {% block head %}{% endblock %}\n  &lt;/head&gt;\n  &lt;body&gt;\n    {% block body %}{% endblock %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;!-- page.html --&gt;\n{% extends 'layout.html' %}\n\n{% block head %}\n  &lt;title&gt;Page&lt;/title&gt;\n{% endblock %}\n\n{% block body %}\n  &lt;p&gt;Page content&lt;/p&gt;\n{% endblock %}\n</code></pre></p> <p>Key points:</p> <ul> <li>Blocks are identified by name</li> <li>A child block fully replaces the parent block</li> <li>Nested blocks are NOT allowed</li> <li>Blocks cannot be conditionally defined</li> <li>Undefined blocks render the parent's default content</li> <li>Block names must be unique within a template</li> </ul>"},{"location":"core_concepts/engine_commands/","title":"Engine Commands","text":"<p>The <code>wfx</code> command-line interface (CLI) provides several commands to interact with WFX, create projects, manage builds, and run the development server. Below is a detailed explanation of each command and its options.</p>"},{"location":"core_concepts/engine_commands/#wfx-new","title":"<code>wfx new</code>","text":"<p>Create a new WFX project.</p> <p>Usage:</p> <pre><code>./wfx new &lt;project_name&gt;\n</code></pre> <p><code>&lt;project_name&gt;</code>: Required. Name of the project to create.</p> <p>If no project name is provided, WFX will display an error.</p>"},{"location":"core_concepts/engine_commands/#wfx-doctor","title":"<code>wfx doctor</code>","text":"<p>Verify system requirements for the current workspace.</p> <p>Deprecated</p> <p>WFX now relies entirely on CMake's build system instead of a custom toolchain, making this check unnecessary. As a result, <code>wfx doctor</code> no longer performs environment, compiler, or dependency validation.</p> <p>The command may be repurposed or reintroduced in the future if additional validation or tooling becomes necessary.</p> <p>Usage (no-op):</p> <pre><code>./wfx doctor\n</code></pre>"},{"location":"core_concepts/engine_commands/#wfx-build","title":"<code>wfx build</code>","text":"<p>Pre-build various parts of the project, such as templates or source code.</p> <p>Usage:</p> <pre><code>./wfx build &lt;target&gt; [options]\n</code></pre>"},{"location":"core_concepts/engine_commands/#compulsory-arguments","title":"Compulsory Arguments","text":"Argument Description &lt;target&gt; Specify which part of the project to build: <code>templates</code> or <code>source</code>"},{"location":"core_concepts/engine_commands/#optional-flags","title":"Optional Flags","text":"Flag Description --debug Currently a no-op. In the future, it will be used to enable runtime debug mode <p>Example:</p> <pre><code>./wfx build source\n</code></pre>"},{"location":"core_concepts/engine_commands/#wfx-run","title":"<code>wfx run</code>","text":"<p>Start the WFX server.</p> <p>Usage:</p> <pre><code>./wfx dev [options]\n</code></pre>"},{"location":"core_concepts/engine_commands/#optional-flags_1","title":"Optional Flags","text":"Option Description Default Requires value? --host Host to bind 127.0.0.1 Yes --port Port to bind 8080 Yes --pin-to-cpu Pin workers to CPU cores - no --use-https Enable HTTPS connection \u2013 No --https-port-override Override default HTTPS port \u2013 No --debug Currently a no-op \u2013 No"},{"location":"core_concepts/engine_commands/#additional-information","title":"Additional Information","text":"<ul> <li>Default specifies the value used by WFX when the option is not explicitly provided.</li> <li>Requires value? indicates whether an option must be followed by a value (for example, <code>--port 3000</code>) or can be used as a standalone flag (for example, <code>--debug</code>).</li> <li><code>--no-cache</code> cannot be combined with <code>--no-source-cache</code> or <code>--no-template-cache</code>.</li> <li><code>--use-https</code> by default uses port 443.</li> <li><code>--https-port-override</code> overrides the HTTPS port using the value provided via <code>--port</code>.</li> </ul> <p>Example:</p> <p><pre><code>./wfx run --host 0.0.0.0 --port 3000 --use-https --https-port-override\n</code></pre> This starts the server on all interfaces, port 3000 and HTTPS enabled.</p>"},{"location":"core_concepts/project_structure/","title":"Project Structure","text":"<p>This page explains the default folder and file layout generated by WFX when you create a new project using:</p> <pre><code>./wfx new &lt;project_name&gt;\n</code></pre> <p>Understanding this structure will help you know where files live, what each directory is responsible for, and how WFX serves content.</p>"},{"location":"core_concepts/project_structure/#directory-overview","title":"Directory Overview","text":"<p>A freshly generated WFX project looks like this:</p> <pre>\n&lt;your_workspace&gt;/\n\u251c\u2500 &lt;your_project_name&gt;/\n\u2502  \u251c\u2500 build/\n\u2502  \u251c\u2500 intermediate/\n\u2502  \u2502\n\u2502  \u251c\u2500 public/\n\u2502  \u2502  \u251c\u2500 style.css\n\u2502  \u2502  \u2514\u2500 script.js\n\u2502  \u2502\n\u2502  \u251c\u2500 src/\n\u2502  \u2502  \u251c\u2500 main.cpp\n\u2502  \u2502  \u2514\u2500 api_entry.cpp\n\u2502  \u2502\n\u2502  \u251c\u2500 templates/\n\u2502  \u2502  \u2514\u2500 index.html\n\u2502  \u2502\n\u2502  \u251c\u2500 .gitignore\n\u2502  \u251c\u2500 CMakeLists.txt\n\u2502  \u2514\u2500 wfx.toml\n\u2502\n\u251c\u2500 WFX/\n\u2502  \u2514\u2500 (engine source code)\n\u2502\n\u2514\u2500 wfx\n</pre> <p>Each directory and file has a specific purpose, explained below.</p>"},{"location":"core_concepts/project_structure/#your_project_name","title":"<code>&lt;your_project_name&gt;/</code>","text":"<p>This directory contains your application code and assets. Everything inside this folder belongs to your WFX project.</p>"},{"location":"core_concepts/project_structure/#build-intermediate","title":"<code>build/</code>, <code>intermediate/</code>","text":"<p>Contains generated build artifacts which are created and managed automatically by WFX and the build system.</p> <p>These directories are generated automatically and must never be edited manually.</p> <p>While they can be safely deleted at any time, it is strongly recommended to delete both directories together rather than deleting one and leaving the other behind.</p>"},{"location":"core_concepts/project_structure/#public","title":"<code>public/</code>","text":"<p>This folder contains all files that are publicly accessible. This includes CSS, JavaScript, images, and any other static assets. Files placed here are automatically served by WFX when a request hits the /public/ route, and can be accessed directly via that route regardless of whether they are referenced by any template (<code>.html</code>).</p> <p>Warning</p> <p>Do not place any sensitive or private files in this folder. All content here is publicly visible. This directory is strictly for static assets meant to be accessible by anyone, and the system assumes no responsibility for accidental exposure.</p>"},{"location":"core_concepts/project_structure/#src","title":"<code>src/</code>","text":"<p>This directory contains all C++ source files that implement your application logic.</p> <p>By default, main.cpp is provided with a few example routes to demonstrate basic functionality. You are free to modify or remove this file as needed. You may also add any number of additional C++ source files and subdirectories inside <code>src/</code>.</p> <p>The WFX build system automatically discovers and compiles all <code>.cpp</code> files located under <code>src/</code>, including those inside nested folders. File and directory naming is entirely up to you, with one exception: api_entry.cpp.</p> <p>api_entry.cpp is a special, engine-required file and must NOT be modified or deleted. It is used internally by WFX to wire application code into the engine.</p>"},{"location":"core_concepts/project_structure/#templates","title":"<code>templates/</code>","text":"<p>This directory is dedicated to storing all HTML files that the server can render and deliver to clients. It should exclusively contain <code>.html</code> files, whether they are static pages (fixed content) or dynamic templates (rendered with SSR).</p> <p>No other file types - such as CSS, JavaScript, or images - should be placed here.</p>"},{"location":"core_concepts/project_structure/#gitignore","title":"<code>.gitignore</code>","text":"<p>The <code>.gitignore</code> file controls which files and directories are excluded from version control. It comes preconfigured to ignore generated directories such as <code>build/</code> and <code>intermediate/</code> by default.</p> <p>You are free to modify <code>.gitignore</code> as needed to suit your workflow (for example, to ignore editor files, local configs, or additional generated artifacts).</p>"},{"location":"core_concepts/project_structure/#cmakeliststxt","title":"<code>CMakeLists.txt</code>","text":"<p><code>CMakeLists.txt</code> defines how your project is configured and built using CMake.</p> <p>Warning</p> <p>Do not modify this file unless you know exactly what you are doing. Incorrect changes may break the build system or cause undefined behavior. If you need custom build logic, it is recommended to understand the existing configuration first before making any changes.</p>"},{"location":"core_concepts/project_structure/#wfxtoml","title":"<code>wfx.toml</code>","text":"<p>The <code>wfx.toml</code> file is the main configuration file for the entire project. It defines settings for both your project and the WFX engine. This file is required for the project to function correctly and should be version-controlled.</p>"},{"location":"core_concepts/project_structure/#wfx","title":"<code>WFX/</code>","text":"<p>The <code>WFX/</code> folder contains the source code of the WFX engine. It is required for building and running the project, as it represents the framework itself rather than your application code.</p> <p>In most cases, you do not need to modify anything in this directory. It is meant to provide the core functionality of the framework and should be treated as a stable, internal component of the project.</p>"},{"location":"core_concepts/project_structure/#wfx_1","title":"<code>wfx</code>","text":"<p>The <code>wfx</code> file is the compiled engine and command-line interface for WFX, built from the <code>WFX/</code> folder using CMake. It powers most of the framework's functionality, including project creation, running the server, and so on.</p> <p>Common commands include:</p> <pre><code> * build    -   Pre-build various parts of WFX\n * doctor   -   Verify system requirements (Deprecated)\n * run      -   Start WFX server\n * new      -   Create a new WFX project\n</code></pre>"},{"location":"core_concepts/project_structure/#next-steps","title":"Next Steps","text":"<p>Now that you have an overview of the project structure, you can start exploring how to work with WFX:</p> <ul> <li>Engine Commands: Learn how <code>wfx</code> CLI works. See Engine Commands for details.  </li> <li>Configuration: Understand and modify <code>wfx.toml</code> to customize project settings. See WFX Settings for details.</li> </ul>"},{"location":"core_concepts/wfx_toml/","title":"WFX Settings","text":"<p>This page defines all supported <code>wfx.toml</code> configuration options in WFX.</p> <p>Note</p> <ul> <li>All settings in this page are applied per worker process, not globally. For example, if <code>max_connections</code> is set to <code>2000</code> and WFX is running with <code>4</code> worker processes, the effective maximum connection capacity is <code>2000 \u00d7 4 = 8000</code> concurrent connections.</li> <li>If a setting does not explicitly mention <code>(In bytes)</code>, its value should be interpreted as a count, not a size. For example, <code>file_cache_size</code> represents the number of cached files, while <code>cache_chunk_size</code> and <code>template_chunk_size</code> explicitly specify <code>(In bytes)</code>, meaning their values are treated as byte sizes.</li> </ul> <p>Warning</p> <p>WFX currently does not validate value ranges or semantics. It only checks for the presence of certain required keys (marked with <code>*</code>). If a required key is missing, startup fails. If a value is invalid but syntactically correct, behavior is undefined and entirely the user's responsibility.</p>"},{"location":"core_concepts/wfx_toml/#project","title":"<code>[Project]</code>","text":"<p>Project-level configuration. This section is mandatory.</p> <pre>\n[Project]\nmiddleware_list = [] # Array of strings\n</pre> <ul> <li><code>middleware_list</code>*: Ordered list of middleware identifiers.<ul> <li>Order matters: middleware executes exactly in declaration order</li> <li>Middleware list may be empty, but the key itself must exist</li> <li>Used to register both engine-provided and user-defined middleware</li> </ul> </li> </ul>"},{"location":"core_concepts/wfx_toml/#build","title":"<code>[Build]</code>","text":"<p>This section of the configuration file controls how WFX manages builds for your project. All values are mandatory.</p> <pre>\n[Build]\ndir_name            = \"build\"          # String\npreferred_config    = \"Debug\"          # String\npreferred_generator = \"Unix Makefiles\" # String\n</pre> <ul> <li> <p><code>dir_name</code>*   The folder where CMake will place all generated build files. This path is relative to the project folder.</p> </li> <li> <p><code>preferred_config</code>*   The default build configuration (e.g., <code>\"Debug\"</code> for development builds or <code>\"Release\"</code> for optimized production builds).  </p> </li> <li> <p><code>preferred_generator</code>*   The default CMake generator to use (e.g., <code>Unix Makefiles</code>, <code>Ninja</code>).  </p> </li> </ul>"},{"location":"core_concepts/wfx_toml/#network","title":"<code>[Network]</code>","text":"<p>Connection-level configuration. All values are optional; defaults are applied if omitted.</p> <pre>\n[Network]\nsend_buffer_max              = 2048    # 32-bit Unsigned Integer (In bytes)\nrecv_buffer_max              = 16384   # 32-bit Unsigned Integer (In bytes)\nrecv_buffer_incr             = 4096    # 32-bit Unsigned Integer (In bytes)\nheader_reserve_hint          = 512     # 16-bit Unsigned Integer (In bytes)\nmax_header_size              = 8192    # 32-bit Unsigned Integer (In bytes)\nmax_body_size                = 8192    # 32-bit Unsigned Integer (In bytes)\nmax_header_count             = 64      # 16-bit Unsigned Integer\nheader_timeout               = 15      # 16-bit Unsigned Integer (In seconds)\nbody_timeout                 = 20      # 16-bit Unsigned Integer (In seconds)\nidle_timeout                 = 40      # 16-bit Unsigned Integer (In seconds)\nmax_connections              = 2000    # 32-bit Unsigned Integer\nmax_connections_per_ip       = 20      # 32-bit Unsigned Integer\nmax_request_burst_per_ip     = 10      # 32-bit Unsigned Integer\nmax_requests_per_ip_per_sec  = 5       # 32-bit Unsigned Integer\n</pre>"},{"location":"core_concepts/wfx_toml/#buffers","title":"Buffers","text":"<ul> <li><code>send_buffer_max</code>: Max total outbound buffer per connection</li> <li><code>recv_buffer_max</code>: Max total inbound buffer per connection</li> <li><code>recv_buffer_incr</code>: Growth increment when receive buffer expands</li> <li><code>header_reserve_hint</code>: Initial allocation hint for headers</li> </ul>"},{"location":"core_concepts/wfx_toml/#headers-body","title":"Headers &amp; Body","text":"<ul> <li><code>max_header_size</code>: Max combined size of all headers</li> <li><code>max_header_count</code>: Max number of headers allowed</li> <li><code>max_body_size</code>: Max request body size</li> </ul>"},{"location":"core_concepts/wfx_toml/#timeouts","title":"Timeouts","text":"<ul> <li><code>header_timeout</code>: Time allowed to fully receive headers</li> <li><code>body_timeout</code>: Time allowed to fully receive body</li> <li><code>idle_timeout</code>: Max idle time before connection is closed</li> </ul>"},{"location":"core_concepts/wfx_toml/#connections","title":"Connections","text":"<ul> <li> <p><code>max_connections</code>   Maximum number of simultaneous connections handled by a single worker process.   Internally, WFX rounds this value up to the nearest multiple of 64 for efficiency.   This is a hard cap; once reached, new connections are rejected by that worker.</p> </li> <li> <p><code>max_connections_per_ip</code>   Maximum number of simultaneous connections allowed from a single IP address per worker process.   This prevents one client from consuming all available connections.</p> </li> <li> <p><code>max_request_burst_per_ip</code>   The number of requests an IP address is allowed to send immediately without being throttled.   Think of this as a bucket of tokens given to each IP when it first connects.</p> </li> <li> <p><code>max_requests_per_ip_per_sec</code>   How fast the token bucket for each IP is refilled, measured in tokens per second.   Once an IP runs out of tokens, further requests are delayed or rejected until tokens are refilled.</p> </li> </ul>"},{"location":"core_concepts/wfx_toml/#env","title":"<code>[ENV]</code>","text":"<p>Environment variable loading. This section is optional.</p> <pre>\n[ENV]\nenv_path = \"...\" # String (Path to .env file)\n</pre> <p>Note</p> <p>On non-Windows systems, the file must have permission <code>600</code> (meaning that only the file's owner has read and write access). Insecure permissions may result in startup failure.</p>"},{"location":"core_concepts/wfx_toml/#ssl","title":"<code>[SSL]</code>","text":"<p>TLS configuration. This section is only used when WFX is running in HTTPS mode. When HTTPS is enabled, certificate paths are mandatory; all other settings are optional.</p> <pre>\n[SSL]\ncert_path            = \"...\"           # String (Path to certificate)\nkey_path             = \"...\"           # String (Path to private key)\ntls13_ciphers        = \"...\"           # String\ntls12_ciphers        = \"...\"           # String\ncurves               = \"X25519:P-256\"  # String\nenable_session_cache = true            # Boolean (true or false)\nenable_ktls          = false           # Boolean (true or false)\nsession_cache_size   = 32768           # 64-bit Unsigned Integer (In bytes)\nmin_proto_version    = 3               # 8-bit Unsigned Integer (1 - 3 only)\nsecurity_level       = 2               # Integer (0 - 5 only)\n</pre>"},{"location":"core_concepts/wfx_toml/#certificates","title":"Certificates","text":"<ul> <li><code>cert_path</code>*: PEM-encoded server certificate</li> <li><code>key_path</code>*: Private key matching the certificate</li> </ul>"},{"location":"core_concepts/wfx_toml/#cipher-suites","title":"Cipher Suites","text":"<ul> <li> <p><code>tls13_ciphers</code>   This lists the preferred encryption methods for TLS 1.3 connections, separated by colons. Example: <code>\"TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256\"</code> tells WFX to first try <code>TLS_AES_128_GCM_SHA256</code> with the client, and only if the client doesn't support it, it will fall back to <code>TLS_CHACHA20_POLY1305_SHA256</code>.</p> </li> <li> <p><code>tls12_ciphers</code>   Same as above but for TLS 1.2 connections. These ciphers define how the server and client encrypt and verify data during the handshake. Example: <code>\"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384\"</code></p> </li> <li> <p><code>curves</code>   Determines the order of Elliptic Curve Diffie-Hellman (ECDHE) curves used for key exchange. Example: <code>\"X25519:P-256\"</code> tells WFX to try X25519 first, then P-256. This affects speed and security of the handshake.</p> </li> </ul>"},{"location":"core_concepts/wfx_toml/#tls-behavior","title":"TLS Behavior","text":"<ul> <li> <p><code>enable_session_cache</code>   When enabled, WFX stores TLS session information on the server so clients can reconnect faster without doing a full handshake. Example: a returning client can skip the expensive key exchange, improving speed at the cost of more RAM usage.</p> </li> <li> <p><code>session_cache_size</code>   Maximum memory size allocated for caching TLS session data. When this limit is reached, older sessions are evicted, causing returning clients to perform a full TLS handshake again.</p> </li> <li> <p><code>enable_ktls</code>   Uses Kernel TLS, which offloads encryption tasks to the OS kernel for higher performance. Older versions of kernel may not fully support this feature.</p> </li> </ul>"},{"location":"core_concepts/wfx_toml/#protocol-security","title":"Protocol &amp; Security","text":"<ul> <li> <p><code>min_proto_version</code>   Sets the minimum TLS version allowed. Example: <code>2</code> means TLS 1.2 or higher only; older clients using TLS 1.0 or 1.1 will be rejected for security reasons.</p> </li> <li> <p><code>security_level</code>   OpenSSL security strictness (0\u20135). Higher values enforce stronger algorithms, longer keys, and stricter certificate checks. Example: <code>2</code> is a reasonable default, while <code>5</code> is extremely strict and may block older clients.</p> </li> </ul>"},{"location":"core_concepts/wfx_toml/#windows","title":"<code>[Windows]</code>","text":"<p>Note</p> <p>This section will be updated once official Windows support is released.</p>"},{"location":"core_concepts/wfx_toml/#linux","title":"<code>[Linux]</code>","text":"<p>Socket and worker configuration for Linux systems only. All settings in this section are optional.</p> <pre>\n[Linux]\nworker_processes = 2     # 32-bit Unsigned Integer\nbacklog          = 1024  # 32-bit Unsigned Integer\n</pre> <ul> <li> <p><code>worker_processes</code>   Controls how many worker processes WFX starts to handle incoming requests. More workers allow better CPU usage on multi-core systems, but too many can waste memory or cause contention. Guidance: Start with significantly fewer workers than total CPU cores, leaving ample headroom for the OS, networking, TLS, and background tasks. Increase gradually only after load testing shows CPU saturation.</p> </li> <li> <p><code>backlog</code>   Sets the maximum number of incoming connections the OS can queue while workers are busy. If this limit is too low, new connections may be rejected during traffic spikes even if the server is healthy.</p> </li> </ul>"},{"location":"core_concepts/wfx_toml/#linuxiouring","title":"<code>[Linux.IoUring]</code>","text":"<p>Note</p> <p>This section will be updated once official IoUring support is released.</p>"},{"location":"core_concepts/wfx_toml/#linuxepoll","title":"<code>[Linux.Epoll]</code>","text":"<p>This is the default Linux networking backend. All settings in this section are optional.</p> <pre>\n[Linux.Epoll]\nmax_events = 1024 # 16-bit Unsigned Integer\n</pre> <ul> <li><code>max_events</code>   Defines how many I/O events <code>epoll_wait</code> can return at once. Higher values allow the server to process more ready connections per loop, while lower values reduce per-iteration work but may increase latency under load.</li> </ul>"},{"location":"core_concepts/wfx_toml/#misc","title":"<code>[Misc]</code>","text":"<p>Defines small engine-level limits that do not fit into other categories, mainly related to caching and internal I/O behavior. This section is optional.</p> <pre>\n[Misc]\nfile_cache_size     = 20     # 16-bit Unsigned Integer\ncache_chunk_size    = 2048   # 16-bit Unsigned Integer (In bytes)\ntemplate_chunk_size = 16384  # 32-bit Unsigned Integer (In bytes)\n</pre> <ul> <li><code>file_cache_size</code>: Number of files cached in memory (LFU)</li> <li><code>template_chunk_size</code>: Max I/O chunk size during template compilation</li> <li><code>cache_chunk_size</code>: Max I/O chunk size for template cache files</li> </ul>"},{"location":"getting_started/first_program/","title":"Your First WFX Program","text":"<p>This guide will help you create and run your first WFX project, verifying that your installation works correctly.</p>"},{"location":"getting_started/first_program/#steps","title":"Steps","text":"<p>Follow the steps below in order, without skipping any.</p>"},{"location":"getting_started/first_program/#1-create-a-new-project","title":"1. Create a new project","text":"<p>Run the following command in your terminal (replace <code>&lt;project_name&gt;</code> with your own project name, e.g., <code>myproj</code>):</p> <pre><code>./wfx new &lt;project_name&gt;\n</code></pre> <p>This will generate a full project folder structure for you.</p>"},{"location":"getting_started/first_program/#2-run-the-wfx-server","title":"2. Run the WFX server","text":"<p>To start the server, run this final command:</p> <pre><code>./wfx run &lt;project_name&gt;\n</code></pre> <p>By default:</p> <ul> <li>The server runs on 127.0.0.1:8080</li> <li>Three routes are preconfigured in <code>main.cpp</code> inside of <code>src/</code> directory:<ul> <li>/     -&gt; serves the <code>index.html</code> from <code>templates/</code> directory</li> <li>/text -&gt; returns plain text</li> <li>/json -&gt; returns JSON object</li> </ul> </li> </ul> <p>Open your browser and visit these routes to verify the content. If you see the expected output, WFX is working correctly.</p>"},{"location":"getting_started/first_program/#congratulations","title":"Congratulations!","text":"<p>WFX is now running on your system.</p> <p>For beginners, it is recommended to continue to the Overview section to learn about the project structure and available engine commands.</p>"},{"location":"getting_started/installation/","title":"Installation","text":"<p>Important</p> <p>WFX currently supports Linux only.</p> <ul> <li>Linux: \u2705 Supported</li> <li>WSL: \u2705 Supported</li> <li>Windows (native): \u274c Not supported</li> <li>macOS: \u274c Not supported</li> </ul>"},{"location":"getting_started/installation/#overview","title":"Overview","text":"<p>This section will guide you through installing all necessary dependencies, setting up WFX, and verifying your environment.</p>"},{"location":"getting_started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>C++20</li> <li>CMake 3.20+</li> <li>Ninja build system (optional, recommended)</li> <li>Git</li> </ul> <p>The following commands install required tools on common Linux distributions. Other distributions may require equivalent packages.</p> <p>Ubuntu / Debian</p> <pre>\n- sudo apt update\n- sudo apt install -y build-essential cmake git\n\n# Optional (recommended)\n- sudo apt install -y ninja-build\n</pre> <p>Fedora</p> <pre>\n- sudo dnf install -y gcc-c++ cmake git\n\n# Optional (recommended)\n- sudo dnf install -y ninja-build\n</pre> <p>Arch Linux</p> <pre>\n- sudo pacman -S --needed base-devel cmake git\n\n# Optional (recommended)\n- sudo pacman -S ninja\n</pre>"},{"location":"getting_started/installation/#steps","title":"Steps","text":"<ol> <li> Create an empty directory (name it whatever you want, 'mydir' is just a placeholder)     <pre>\n- mkdir mydir\n- cd mydir</pre> </li> <li> Clone the WFX repository <pre>\n- git clone https://github.com/Altered-commits/WFX.git\n- cd WFX\n- git checkout dev</pre> </li> <li> Configure and build WFX <p>       Choose one of the following build methods:     </p> <p> Option A (recommended): Build with Ninja       Provides faster build times and better parallelism     </p> <pre>\n- cmake -S . -B build -G Ninja\n- cmake --build build</pre> <p> Option B: Build with the default CMake generator       Use this option if Ninja is not installed     </p> <pre>\n- cmake -S . -B build\n- cmake --build build</pre> </li> <li> Move the built executable to your main directory <pre>\n- mv wfx ..\n- cd ..</pre> </li> <li> Verify installation <pre>\n- ./wfx</pre>     You should see WFX being printed.   </li> </ol>"},{"location":"getting_started/installation/#documentation-optional","title":"Documentation (Optional)","text":"<p>This section explains how to build and preview the WFX documentation locally.</p> <p>Documentation is built using MkDocs Material. Do not install plain <code>mkdocs</code>; it is missing required features and extensions used by this project.</p> <p>Note</p> <p>Documentation can be built on Linux, macOS, and Windows, even though WFX itself currently supports Linux only.</p> <p>Requirements</p> <ul> <li>Python 3.8+</li> <li>pip</li> </ul> <p>Verify Python is available:</p> <pre>\n- python3 --version\n</pre> <p>Virtual environment setup</p> <p>Creating a virtual environment is strongly recommended on all platforms to ensure reproducible documentation builds and to avoid dependency conflicts.</p> <p>Linux / macOS</p> <pre>\n- python3 -m venv .venv\n- source .venv/bin/activate\n</pre> <p>Windows (PowerShell)</p> <pre>\n- python -m venv .venv\n- .venv\\Scripts\\Activate.ps1\n</pre> <p>Install dependencies</p> <p>Install MkDocs Material (not plain MkDocs):</p> <pre>\n- pip install mkdocs-material\n</pre> <p>This package includes all required themes, extensions, and plugins used by WFX documentation.</p> <p>Serve the documentation locally</p> <p>From the repository root:</p> <pre>\n- mkdocs serve\n</pre> <p>Then open your browser at:</p> <pre>\n- http://127.0.0.1:8000\n</pre>"},{"location":"getting_started/installation/#notes","title":"Notes","text":"<ul> <li>Windows and macOS will be added in the future.</li> <li>The most recent and up-to-date code is available on the <code>dev</code> branch. The <code>main</code> branch will host stable releases in the future. Until then, it is recommended to use the <code>dev</code> branch.</li> <li>WFX is currently tested only on Ubuntu and Debian-based Linux distributions. Other Linux distributions may work, but are untested.</li> <li>Kernel TLS (used for HTTPS acceleration) requires a sufficiently recent Linux kernel. Older kernels may compile but will not support certain runtime features.</li> </ul> <p>Continue to Your First WFX Program</p>"}]}